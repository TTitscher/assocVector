################################################################################
# AssocVector...
################################################################################

The AssocVector is a container similar to Loki::AssocVector created by Andrei Alexandrescu. However 'insert' and 'erase' operations in significantly optimized {O(sqrt(N)) vs. O(N)}. All the others operations should not be slower.



################################################################################
# Project Homepage...
################################################################################

http://lukaszczerwinski.pl/assoc_vector.en.html

https://github.com/wo3kie/AssocVector



################################################################################
# License...
################################################################################

AssocVector is developed under the BSD license. It is allowed to distribute source, use it and modify without any limitations either for personal or commercial goal. Whilst distributing source code using AssocVector it is obligate to mark the author

There is absolutely no guarantee that AssocVector will work without any errors and that is free of any bugs. AssocVector author is not responsible for any damages, mind and financial loses related with AssocVector using.



################################################################################
# How to use it...
################################################################################
1) Interface of AssocVector is almost the same like std::map

    AssocVector< std::string, int > av;

    av[ "c++" ] = 1983;
    av[ "java" ] = 1995;
    av[ "scala" ] = 2001;

    assert( av[ "c++" ] == 1983 );
    assert( av.count( "java" ) == 1 );
    assert( av.find( "scala" ) != av.end() );

2) Insert operation is buffered that's why may be much faster

    AssocVector< std::string, int > av;

    for( ... ){
        av.insert( AssocVector::value_type( key, value ) );
    }

3) merge operation enforce merging buffer with main storage, after it AssocVector is like an array

    AssocVector< std::string, int > av;

    for( ... ){
        av.insert( AssocVector::value_type( key, value ) );
    }

    av.merge();

4) Of course AssocVector works fine even if merge operation is never called.



################################################################################
# How it works...
################################################################################

AssocVector is composed of three arrays,
* first called 'storage', with objects
* second called 'buffer', with objects
* third called 'erased', with pointers to erased objects

Every arrays are keep sorted all the time. Insert operation puts new items into 'buffer'. Since 'buffer' is much shorter than 'storage' it is quite effective. When 'buffer' is completely full it is merged into 'storage'. This operation may be longer however it is performed only sometimes.

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |
+---+---+---+

After insert 2

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 2 |   |   |
+---+---+---+

After insert 3

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 2 | 3 |   |
+---+---+---+

After insert 49

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 2 | 3 | 49|
+---+---+---+

After insert 5

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 49| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 5 |   |   |
+---+---+---+

After AssocVector::merge called

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 49| 50|   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...
|   |   |   |
+---+---+---+

All the time size of 'buffer' is kept as sqrt('storage'.size()) which is an optimal coefficient for it.

Erasing items is implemented in two ways. Items present in 'buffer' are erased immediately. Items in 'storage' are not erased immediately, but they are marked as erased using 'erased' table. If 'erased' table is filled in completely such items are really removed from 'storage'. Size of 'erased' is the same as size of 'buffer' and equal sqrt('storage'.size()).

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 2 | 3 | 49|
+---+---+---+
|   |   |   |
+---+---+---+

After erase 6

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 2 | 3 | 49|
+---+---+---+
|*6 |   |   |
+---+---+---+

After erase 2

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 3 | 49|   |
+---+---+---+
|*6 |   |   |
+---+---+---+


After erase 49

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 3 |   |   |
+---+---+---+
|*6 |   |   |
+---+---+---+

After erase 0

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 3 |   |   |
+---+---+---+
|*0 |*6 |   |
+---+---+---+

After erase 11

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 4 | 6 | 8 | 9 | 11| 13| 32| 35| 47| 48| 50|
+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 3 |   |   |
+---+---+---+
|*0 |*6 |*11|
+---+---+---+

After erase 50

+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 3 | 4 | 8 | 9 | 13| 32| 35| 47| 48|   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |
+---+---+---+
|   |   |   |
+---+---+---+



################################################################################
# Requirements...
################################################################################

AssocVector depends on following externals:
• C++/STL



################################################################################
# Bugs...
################################################################################
There are no bugs. There are "features".



################################################################################
# Support and further development...
################################################################################

• 1 August, version 1.0.0
Fixing all potential bugs found in 0.9.9.

• 1 October, version 1.1.0
Full support for C++11:
- AssocVector::AssocVector( value_type && )
- AssocVector::::emplace
- AssocVector::cbegin / cend / crbegin / crend
- AssocVector::insert( value_type && )
- AssocVector::at( key_type )
...

(more details: http://en.cppreference.com/w/cpp/container/map)
